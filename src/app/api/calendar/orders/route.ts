import { NextRequest } from 'next/server';
import { prisma, createSuccessResponse, createErrorResponse } from '@/lib/api-utils';

// GET /api/calendar/orders - Get calendar view of scheduled orders
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const month = searchParams.get('month'); // Format: YYYY-MM
    const vendorId = searchParams.get('vendorId');

    if (!month) {
      return createErrorResponse(
        'VALIDATION_ERROR',
        'month parameter is required (format: YYYY-MM)',
        400
      );
    }

    // Parse month and calculate date range
    const [year, monthNum] = month.split('-').map(Number);
    const startDate = new Date(year, monthNum - 1, 1);
    startDate.setHours(0, 0, 0, 0);

    const endDate = new Date(year, monthNum, 0); // Last day of month
    endDate.setHours(23, 59, 59, 999);

    const where: any = {
      scheduleDate: {
        gte: startDate,
        lte: endDate,
      },
    };

    if (vendorId) {
      where.vendorId = vendorId;
    }

    // Get scheduled orders for the month
    const orders = await prisma.scheduledOrder.findMany({
      where,
      include: {
        vendor: {
          select: {
            id: true,
            name: true,
          },
        },
        purchaseOrder: {
          select: {
            id: true,
            orderNumber: true,
            status: true,
          },
        },
      },
      orderBy: {
        scheduleDate: 'asc',
      },
    });

    // Get all vendors (not just those with schedules)
    const vendors = await prisma.vendor.findMany({
      select: {
        id: true,
        name: true,
      },
      orderBy: {
        name: 'asc',
      },
    });

    // Group orders by date for easy calendar rendering
    const ordersByDate: Record<string, any[]> = {};
    for (const order of orders) {
      const dateKey = order.scheduleDate.toISOString().split('T')[0];
      if (!ordersByDate[dateKey]) {
        ordersByDate[dateKey] = [];
      }
      ordersByDate[dateKey].push({
        id: order.id,
        vendorId: order.vendorId,
        vendorName: order.vendor.name,
        status: order.status,
        deliveryDate: order.deliveryDate,
        orderDeadline: order.orderDeadline,
        orderedBy: order.orderedBy,
        notes: order.notes,
        isRecurring: order.isRecurring,
        recurringPattern: order.recurringPattern,
        recurringEndDate: order.recurringEndDate,
        customDays: order.customDays ? JSON.parse(order.customDays) : null,
        purchaseOrder: order.purchaseOrder,
        autoGenerated: order.autoGenerated,
      });
    }

    // Summary statistics
    const summary = {
      totalOrders: orders.length,
      upcoming: orders.filter(o => o.status === 'upcoming').length,
      due: orders.filter(o => o.status === 'due').length,
      placed: orders.filter(o => o.status === 'placed').length,
      delivered: orders.filter(o => o.status === 'delivered').length,
    };

    // Transform orders to include parsed customDays
    const transformedOrders = orders.map(order => ({
      ...order,
      customDays: order.customDays ? JSON.parse(order.customDays) : null,
    }));

    return createSuccessResponse({
      month,
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0],
      orders: transformedOrders,
      ordersByDate,
      vendors,
      summary,
    });
  } catch (error: any) {
    console.error('Error fetching calendar orders:', error);
    return createErrorResponse(
      'FETCH_ERROR',
      `Failed to fetch calendar orders: ${error.message}`,
      500
    );
  }
}

// POST /api/calendar/orders - Create new scheduled order
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      vendorId,
      deliveryDate,
      orderDeadline,
      orderedBy,
      notes,
      isRecurring,
      recurringPattern,
      recurringEndDate,
      customDays,
    } = body;

    if (!vendorId || !deliveryDate) {
      return createErrorResponse(
        'VALIDATION_ERROR',
        'vendorId and deliveryDate are required',
        400
      );
    }

    // If it's a recurring order, create multiple scheduled orders
    if (isRecurring && recurringPattern !== 'none') {
      const orders = [];
      const startDate = new Date(deliveryDate);
      const endDate = recurringEndDate ? new Date(recurringEndDate) : new Date(startDate.getFullYear() + 1, startDate.getMonth(), startDate.getDate()); // Default 1 year ahead

      let currentDate = new Date(startDate);

      while (currentDate <= endDate) {
        // Check if this date matches the recurring pattern
        let shouldCreate = false;

        switch (recurringPattern) {
          case 'weekly':
            shouldCreate = true;
            break;
          case 'biweekly':
            const weeksDiff = Math.floor((currentDate.getTime() - startDate.getTime()) / (7 * 24 * 60 * 60 * 1000));
            shouldCreate = weeksDiff % 2 === 0;
            break;
          case 'monthly':
            shouldCreate = currentDate.getDate() === startDate.getDate();
            break;
          case 'custom':
            shouldCreate = customDays && customDays.includes(currentDate.getDay());
            break;
        }

        if (shouldCreate) {
          orders.push({
            vendorId,
            scheduleDate: new Date(currentDate),
            deliveryDate: new Date(currentDate),
            orderDeadline: orderDeadline || null,
            orderedBy: orderedBy || null,
            notes: notes || null,
            status: 'upcoming',
            autoGenerated: false,
            isRecurring: true,
            recurringPattern,
            recurringEndDate: recurringEndDate ? new Date(recurringEndDate) : null,
            customDays: customDays ? JSON.stringify(customDays) : null,
          });
        }

        // Increment date based on pattern
        switch (recurringPattern) {
          case 'weekly':
          case 'biweekly':
            currentDate.setDate(currentDate.getDate() + 7);
            break;
          case 'monthly':
            currentDate.setMonth(currentDate.getMonth() + 1);
            break;
          case 'custom':
            currentDate.setDate(currentDate.getDate() + 1);
            break;
        }
      }

      // Create all orders
      await prisma.scheduledOrder.createMany({
        data: orders,
      });

      return createSuccessResponse(
        { created: orders.length },
        `Created ${orders.length} recurring orders`,
        201
      );
    } else {
      // Create single order
      const order = await prisma.scheduledOrder.create({
        data: {
          vendorId,
          scheduleDate: new Date(deliveryDate),
          deliveryDate: new Date(deliveryDate),
          orderDeadline: orderDeadline || null,
          orderedBy: orderedBy || null,
          notes: notes || null,
          status: 'upcoming',
          autoGenerated: false,
          isRecurring: false,
        },
        include: {
          vendor: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });

      return createSuccessResponse(order, 'Order created successfully', 201);
    }
  } catch (error: any) {
    console.error('Error creating order:', error);
    return createErrorResponse(
      'CREATE_ERROR',
      `Failed to create order: ${error.message}`,
      500
    );
  }
}

export const dynamic = 'force-dynamic';
