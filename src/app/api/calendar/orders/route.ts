import { NextRequest } from 'next/server';
import { prisma, createSuccessResponse, createErrorResponse } from '@/lib/api-utils';

// GET /api/calendar/orders - Get calendar view of scheduled orders
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const month = searchParams.get('month'); // Format: YYYY-MM
    const vendorId = searchParams.get('vendorId');

    if (!month) {
      return createErrorResponse(
        'VALIDATION_ERROR',
        'month parameter is required (format: YYYY-MM)',
        400
      );
    }

    // Parse month and calculate date range
    const [year, monthNum] = month.split('-').map(Number);
    const startDate = new Date(year, monthNum - 1, 1);
    startDate.setHours(0, 0, 0, 0);

    const endDate = new Date(year, monthNum, 0); // Last day of month
    endDate.setHours(23, 59, 59, 999);

    const where: any = {
      scheduleDate: {
        gte: startDate,
        lte: endDate,
      },
    };

    if (vendorId) {
      where.vendorId = vendorId;
    }

    // Get scheduled orders for the month
    const orders = await prisma.scheduledOrder.findMany({
      where,
      include: {
        vendor: {
          select: {
            id: true,
            name: true,
          },
        },
        purchaseOrder: {
          select: {
            id: true,
            orderNumber: true,
            status: true,
          },
        },
      },
      orderBy: {
        scheduleDate: 'asc',
      },
    });

    // Get all vendors with active schedules
    const vendors = await prisma.vendor.findMany({
      where: {
        orderSchedules: {
          some: {
            isActive: true,
          },
        },
      },
      select: {
        id: true,
        name: true,
      },
      orderBy: {
        name: 'asc',
      },
    });

    // Group orders by date for easy calendar rendering
    const ordersByDate: Record<string, any[]> = {};
    for (const order of orders) {
      const dateKey = order.scheduleDate.toISOString().split('T')[0];
      if (!ordersByDate[dateKey]) {
        ordersByDate[dateKey] = [];
      }
      ordersByDate[dateKey].push({
        id: order.id,
        vendorId: order.vendorId,
        vendorName: order.vendor.name,
        status: order.status,
        deliveryDate: order.deliveryDate,
        purchaseOrder: order.purchaseOrder,
        autoGenerated: order.autoGenerated,
      });
    }

    // Summary statistics
    const summary = {
      totalOrders: orders.length,
      upcoming: orders.filter(o => o.status === 'upcoming').length,
      due: orders.filter(o => o.status === 'due').length,
      placed: orders.filter(o => o.status === 'placed').length,
      delivered: orders.filter(o => o.status === 'delivered').length,
    };

    return createSuccessResponse({
      month,
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0],
      orders,
      ordersByDate,
      vendors,
      summary,
    });
  } catch (error: any) {
    console.error('Error fetching calendar orders:', error);
    return createErrorResponse(
      'FETCH_ERROR',
      `Failed to fetch calendar orders: ${error.message}`,
      500
    );
  }
}

export const dynamic = 'force-dynamic';
