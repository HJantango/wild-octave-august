import { NextRequest } from 'next/server';
import { prisma, createSuccessResponse, createErrorResponse } from '@/lib/api-utils';

// Helper function to get day of week index (0 = Sunday, 1 = Monday, ...)
function getDayOfWeekIndex(dayName: string): number {
  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  return days.indexOf(dayName);
}

// Helper function to add days to a date
function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

// Helper function to get next occurrence of a day of week
function getNextDayOfWeek(startDate: Date, targetDayIndex: number): Date {
  const result = new Date(startDate);
  const currentDay = result.getDay();
  let daysToAdd = targetDayIndex - currentDay;
  if (daysToAdd <= 0) {
    daysToAdd += 7; // Move to next week
  }
  result.setDate(result.getDate() + daysToAdd);
  return result;
}

// Check if date should be skipped (public holiday)
async function isPublicHoliday(date: Date): Promise<boolean> {
  const holiday = await prisma.publicHoliday.findFirst({
    where: {
      date: date,
      state: 'NSW', // Wild Octave is in NSW
    },
  });
  return !!holiday;
}

// POST /api/scheduled-orders/generate - Generate scheduled orders for upcoming dates
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const daysAhead = body.daysAhead || 30; // Default to 30 days ahead

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const endDate = addDays(today, daysAhead);

    // Get all active vendor schedules
    const schedules = await prisma.vendorOrderSchedule.findMany({
      where: { isActive: true },
      include: {
        vendor: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    const created: any[] = [];
    const skipped: any[] = [];

    for (const schedule of schedules) {
      const targetDayIndex = getDayOfWeekIndex(schedule.orderDay);

      if (targetDayIndex === -1) {
        skipped.push({
          vendorName: schedule.vendor.name,
          reason: `Invalid order day: ${schedule.orderDay}`,
        });
        continue;
      }

      // Start from the next occurrence of the target day
      let currentDate = getNextDayOfWeek(today, targetDayIndex);

      // Generate orders for this schedule
      let weekCount = 0;
      while (currentDate <= endDate) {
        // Check frequency and week offset
        let shouldGenerate = true;
        if (schedule.frequency === 'bi-weekly' || schedule.frequency === 'fortnightly') {
          shouldGenerate = (weekCount % 2) === schedule.weekOffset;
        } else if (schedule.frequency === 'monthly') {
          shouldGenerate = weekCount === 0 || (weekCount % 4) === schedule.weekOffset;
        } else if (schedule.frequency === 'bi-monthly') {
          shouldGenerate = weekCount === 0 || (weekCount % 8) === schedule.weekOffset;
        }

        if (shouldGenerate) {
          // Check if this date is a public holiday
          const isHoliday = await isPublicHoliday(currentDate);

          if (isHoliday) {
            skipped.push({
              vendorName: schedule.vendor.name,
              date: currentDate.toISOString().split('T')[0],
              reason: 'Public holiday',
            });
          } else {
            // Check if scheduled order already exists for this date
            const existing = await prisma.scheduledOrder.findFirst({
              where: {
                vendorId: schedule.vendorId,
                scheduleDate: currentDate,
              },
            });

            if (!existing) {
              // Calculate delivery date
              const deliveryDate = addDays(currentDate, schedule.leadTimeDays);

              // Create scheduled order
              const scheduledOrder = await prisma.scheduledOrder.create({
                data: {
                  vendorId: schedule.vendorId,
                  scheduleDate: currentDate,
                  deliveryDate: deliveryDate,
                  status: 'upcoming',
                  autoGenerated: true,
                  notes: `Auto-generated from ${schedule.frequency} schedule`,
                },
                include: {
                  vendor: {
                    select: {
                      id: true,
                      name: true,
                    },
                  },
                },
              });

              created.push({
                id: scheduledOrder.id,
                vendorName: scheduledOrder.vendor.name,
                scheduleDate: scheduledOrder.scheduleDate,
                deliveryDate: scheduledOrder.deliveryDate,
              });
            }
          }
        }

        // Move to next week
        currentDate = addDays(currentDate, 7);
        weekCount++;
      }
    }

    return createSuccessResponse({
      summary: {
        created: created.length,
        skipped: skipped.length,
        daysAhead,
        schedulesProcessed: schedules.length,
      },
      details: {
        created,
        skipped,
      },
    }, `Generated ${created.length} scheduled orders`);
  } catch (error: any) {
    console.error('Error generating scheduled orders:', error);
    return createErrorResponse(
      'GENERATE_ERROR',
      `Failed to generate scheduled orders: ${error.message}`,
      500
    );
  }
}

export const dynamic = 'force-dynamic';
